import numpy as np

# Estados ocultos (fonemas)
states = ['A', 'B', 'C']
N = len(states)

# Observaciones (características discretizadas del audio)
observations = ['o1', 'o2', 'o3']
M = len(observations)

# Secuencia de observaciones
seq_obs = ['o1', 'o2', 'o2', 'o3', 'o1']

# Probabilidades iniciales
pi = np.array([0.4, 0.4, 0.2])

# Transición entre fonemas
A = np.array([[0.6, 0.3, 0.1],
              [0.2, 0.7, 0.1],
              [0.1, 0.3, 0.6]])

# Emisión: P(observación|estado)
B = np.array([[0.7,0.2,0.1],
              [0.1,0.8,0.1],
              [0.1,0.2,0.7]])

# Forward (Adelante)
T_len = len(seq_obs)
alpha = np.zeros((T_len, N))
alpha[0,:] = pi * B[:, observations.index(seq_obs[0])]
for t in range(1, T_len):
    for j in range(N):
        alpha[t,j] = B[j, observations.index(seq_obs[t])] * np.sum(alpha[t-1,:]*A[:,j])

# Posterior de estados
posterior = alpha / alpha.sum(axis=1, keepdims=True)

print("Probabilidad de cada fonema en cada tiempo:")
for t, p in enumerate(posterior):
    print(f"Tiempo {t+1} ({seq_obs[t]}): {dict(zip(states, p.round(3)))}")