# - calcular flujo óptico denso (Farneback) entre dos frames
# - visualizar vectores de movimiento y hacer mapa de magnitud/dirección
# ------------------------------------------------------------
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Para demo: generamos dos frames con un desplazamiento global
h, w = 200, 300
frame1 = np.zeros((h,w,3), dtype=np.uint8)
cv2.circle(frame1, (80,100), 30, (255,255,255), -1)
cv2.rectangle(frame1, (150,60),(200,120),(255,255,255), -1)
# frame2: todo movido a la derecha 10 px y abajo 5 px
M = np.float32([[1,0,10],[0,1,5]])
frame2 = cv2.warpAffine(frame1, M, (w,h))

# convertir a gris
prv = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
nxt = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)

# calcular flujo óptico de Farneback (denso)
flow = cv2.calcOpticalFlowFarneback(prv, nxt, None,
                                   pyr_scale=0.5, levels=3, winsize=15,
                                   iterations=3, poly_n=5, poly_sigma=1.2, flags=0)

# flow es un array h x w x 2 (vx, vy)
mag, ang = cv2.cartToPolar(flow[...,0], flow[...,1])

# visualizar HSV: hue = ang, value = mag normalizada
hsv = np.zeros((h,w,3), dtype=np.uint8)
hsv[...,0] = ang * 180 / np.pi / 2  # map angle to [0,180]
hsv[...,1] = 255
hsv[...,2] = np.minimum(255, (mag*10).astype(np.uint8))
bgr_flow = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

# Mapa de vectores: muestreamos a una grilla cada N pixeles
step = 15
vis = frame2.copy()
for y in range(0, h, step):
    for x in range(0, w, step):
        fx, fy = flow[y,x]
        cv2.arrowedLine(vis, (x,y), (int(x+fx), int(y+fy)), (0,255,0), 1, tipLength=0.3)

plt.figure(figsize=(12,6))
plt.subplot(1,3,1); plt.title("Frame1"); plt.imshow(cv2.cvtColor(frame1, cv2.COLOR_BGR2RGB)); plt.axis('off')
plt.subplot(1,3,2); plt.title("Frame2 y vectores (submuestreo)"); plt.imshow(cv2.cvtColor(vis, cv2.COLOR_BGR2RGB)); plt.axis('off')
plt.subplot(1,3,3); plt.title("Flujo visual HSV"); plt.imshow(cv2.cvtColor(bgr_flow, cv2.COLOR_BGR2RGB)); plt.axis('off')
plt.show()