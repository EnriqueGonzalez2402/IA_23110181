import heapq  # Para crear una cola de prioridad seg√∫n heur√≠stica

# Grafo: nodos y sus vecinos
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

# Costos reales (para UCS, A*)
costs = {
    ('A', 'B'): 2,
    ('A', 'C'): 1,
    ('B', 'D'): 3,
    ('B', 'E'): 1,
    ('C', 'F'): 4,
    ('E', 'F'): 1
}

# Heur√≠stica: estimaci√≥n de la distancia restante al objetivo F
heuristic = {
    'A': 6,
    'B': 4,
    'C': 2,
    'D': 7,
    'E': 1,
    'F': 0
}

start = 'A'
goal = 'F'

def a_star_search(graph, start, goal, costs, heuristic):
    # Cola de prioridad: (f = g+h, g = costo real acumulado, camino)
    queue = [(heuristic[start], 0, [start])]

    while queue:
        f, g, path = heapq.heappop(queue)
        node = path[-1]

        # Si llegamos al objetivo, devolvemos camino y costo real
        if node == goal:
            return path, g

        for neighbor in graph[node]:
            # g_new = costo acumulado hasta este vecino
            g_new = g + costs.get((node, neighbor), 1)
            f_new = g_new + heuristic[neighbor]  # f = g + h
            heapq.heappush(queue, (f_new, g_new, path + [neighbor]))

    return None, float('inf')

path_astar, cost_astar = a_star_search(graph, start, goal, costs, heuristic)
print("üîü A*:", path_astar, "| Costo:", cost_astar)